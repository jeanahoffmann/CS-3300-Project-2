<html>
  <head>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://d3js.org/topojson.v3.min.js"></script>
    <style>
      * {
        font-family: "Inter", sans-serif;
      }

      body {
        margin-top: 40px;
        background-color: black;
        color: white;
      }

      h3 {
        margin-top: 40px;
      }

      .myCircle:hover {
        stroke: black;
      }

      .gridlines .domain {
        display: none;
      }

      .gridlines line {
        stroke: #aaa;
      }

      div#dashboard {
        display: flex;
      }
    </style>
  </head>

  <body>
    <h3>CS 3300 Project 2: Simon Tian, Colin Wu, and Jeana Hoffmann</h3>
    <div id="dashboard">
      <svg id="choropleth" height="800" width="900"></svg>
      <svg id="spiderPlot" width="450" height="450"></svg>
    </div>
    <ul id="legend"></ul>

    <script>
      // Generalized code for creating a radar chart, takes in container id to generate the chart in and formatted data
      function createRadarChart(container, data) {
        // Select the container and append an SVG for this radar chart
        const svg = d3.select(`svg#${container}`);
        const width = svg.attr("width");
        const height = svg.attr("height");

        const features = Object.keys(Object.values(data)[0]);

        // Set dimensions and center coordinates
        const radius = Math.min(width, height) / 2 - 80;
        const centerX = width / 2,
          centerY = height / 2;

        // Calculate the maximum value for each feature across the dataset
        const maxValues = {};
        features.forEach(feature => {
          maxValues[feature] = d3.max(Object.values(data), d => d[feature]);
        });

        // Create a specific scale for each feature based on its maximum value
        const scales = {};
        features.forEach(feature => {
          scales[feature] = d3
            .scaleLinear()
            .range([0, radius])
            .domain([0, maxValues[feature]]);
        });

        // Angle for each feature axis
        const angleSlice = (Math.PI * 2) / features.length;

        // Radar line generator function
        const radarLine = d3
          .lineRadial()
          .radius(d => scales[d.feature](d.value)) // Use feature-specific scale
          .angle((d, i) => i * angleSlice)
          .curve(d3.curveLinearClosed);

        const radarGroup = svg
          .append("g")
          .attr("transform", `translate(${centerX}, ${centerY})`);

        // Draw grid and axes
        function drawAxes() {
          const axisGrid = radarGroup.append("g").attr("class", "axisWrapper");

          const numLevels = 5;
          for (let level = 1; level <= numLevels; level++) {
            const levelRadius = (radius / numLevels) * level;

            axisGrid
              .append("circle")
              .attr("class", "grid-circle")
              .attr("r", levelRadius)
              .style("fill", "#CDCDCD")
              .style("stroke", "#CDCDCD")
              .style("fill-opacity", 0.1);

            features.forEach((feature, i) => {
              const featureMax = maxValues[feature]; // Maximum value for the feature
              const scale = scales[feature]; // Scale for this feature

              // Calculate the value for this ring level for this feature
              const ringValue = Math.round((featureMax / numLevels) * level);

              // Position the label on the ring at the correct angle for the feature
              axisGrid
                .append("text")
                .attr("class", "ring-label")
                .attr("x", levelRadius * Math.cos(angleSlice * i - Math.PI / 2))
                .attr("y", levelRadius * Math.sin(angleSlice * i - Math.PI / 2))
                .attr("dy", "0.35em")
                .style("font-size", "10px")
                .style("fill", "white")
                .style("text-anchor", "middle")
                .text(ringValue); // Set label text to the calculated ring value
            });
          }

          const axis = axisGrid
            .selectAll(".axis")
            .data(features)
            .enter()
            .append("g")
            .attr("class", "axis");

          axis
            .append("line")
            .attr("x1", 0)
            .attr("y1", 0)
            .attr(
              "x2",
              (d, i) =>
                scales[d](maxValues[d]) * Math.cos(angleSlice * i - Math.PI / 2)
            )
            .attr(
              "y2",
              (d, i) =>
                scales[d](maxValues[d]) * Math.sin(angleSlice * i - Math.PI / 2)
            )
            .style("stroke", "grey")
            .style("stroke-width", "2px");

          axis
            .append("text")
            .attr("class", "legend")
            .attr("text-anchor", "middle")
            .attr("dy", "0.35em")
            .style("fill", "white")
            .attr(
              "x",
              (d, i) => (radius + 25) * Math.cos(angleSlice * i - Math.PI / 2)
            )
            .attr(
              "y",
              (d, i) => (radius + 25) * Math.sin(angleSlice * i - Math.PI / 2)
            )
            .text(d => d)
            .style("font-size", "11px");

          d3.selectAll(".ring-label").raise();
        }

        // Radar chart update function that takes a key to select the row
        function updateRadar(key) {
          let dataPoint = data[key];

          // Display no polygon if there is no data
          if (!dataPoint) {
            dataPoint = {};
          }

          const formattedData = features.map(feature => ({
            feature: feature,
            value: dataPoint[feature] || 0,
          }));

          const radarArea = radarGroup
            .selectAll(".radar-chart-area")
            .data([formattedData]);

          radarArea
            .join("path")
            .attr("class", "radar-chart-area")
            .transition()
            .duration(750)
            .attr("d", radarLine)
            .style("fill", "lightblue")
            .style("stroke", "blue")
            .style("fill-opacity", 0.5);
        }

        // Initial drawing of axes and the first data point
        drawAxes();
        updateRadar();

        // Return the updateRadar function for external access
        return { updateRadar };
      }
    </script>

    <script>
      let choropleth = d3.select("svg#choropleth");
      const mapHeight = choropleth.attr("height");
      const mapWidth = choropleth.attr("width");

      const requestChoropleth = async function () {
        let nyc = await d3.json("data/nyc_zips.topo.json");
        let crashData = await d3.csv("data/zip_crashes.csv", d3.autoType);
        let factorData = await d3.csv("data/factors.csv", d3.autoType);
        console.log(nyc);
        console.log(crashData);
        console.log(factorData);

        const factorDict = Object.fromEntries(
          factorData.map(row => {
            const { "ZIP CODE": zipCode, ...rest } = row; // Destructure to exclude "ZIP CODE"
            return [zipCode, rest];
          })
        );

        const factorChart = createRadarChart("spiderPlot", factorDict);

        let zips = topojson.feature(
          nyc,
          nyc.objects["nyc-zip-code-tabulation-areas-polygons"]
        );
        let zipsMesh = topojson.mesh(
          nyc,
          nyc.objects["nyc-zip-code-tabulation-areas-polygons"]
        );
        let projection = d3.geoMercator().fitSize([mapWidth, mapHeight], zips);
        let path = d3.geoPath().projection(projection);

        plasma = d3.interpolatePlasma;
        let colors = [
          plasma(0),
          plasma(0.25),
          plasma(0.5),
          plasma(0.75),
          plasma(1),
        ];
        crashExtent = d3.extent(crashData, d => d["CRASHES"]);
        let colorScale = d3.scaleQuantile(colors).domain(crashExtent);

        let crashMap = {};
        crashData.forEach(function (d) {
          crashMap[d["ZIP CODE"]] = d["CRASHES"];
        });

        let map = choropleth.append("g");
        map
          .selectAll("path.zip")
          .filter(d => d.uniqueId === 12345)
          .data(zips.features)
          .join("path")
          .attr("fill", d => colorScale(crashMap[d.properties["postalCode"]]))
          .attr("d", path)
          .on("mouseover", mouseEntersZip)
          .on("mouseout", mouseLeavesZip);

        map
          .append("path")
          .datum(zipsMesh)
          .attr("class", "outline")
          .attr("fill", "none")
          .attr("stroke", "black")
          .attr("stroke-width", 1)
          .attr("d", path);

        let momesh = map
          .append("path")
          .attr("class", "outline")
          .attr("fill", "none")
          .style("stroke", "white")
          .style("stroke-width", 3);

        let tooltipWidth = 120;
        let tooltipHeight = 40;

        let tooltip = map
          .append("g")
          .attr("class", "tooltip")
          .attr("visibility", "hidden");
        tooltip
          .append("rect")
          .attr("fill", "black")
          .attr("opacity", 0.9)
          .attr("x", -tooltipWidth / 2.0)
          .attr("y", 0)
          .attr("rx", 10)
          .attr("ry", 10)
          .attr("width", tooltipWidth)
          .attr("height", tooltipHeight);
        let txt = tooltip
          .append("text")
          .attr("fill", "white")
          .attr("text-anchor", "middle")
          .attr("alignment-baseline", "hanging")
          .attr("x", 0)
          .attr("y", 2);
        let txt2 = tooltip
          .append("text")
          .attr("fill", "white")
          .attr("text-anchor", "middle")
          .attr("alignment-baseline", "hanging")
          .attr("x", 0)
          .attr("y", 22);

        function mouseEntersZip() {
          let zip = d3.select(this);

          zipID = zip.datum().id;

          var mo = topojson.mesh(
            nyc,
            nyc.objects["nyc-zip-code-tabulation-areas-polygons"],
            function (a, b) {
              return a.id === zipID || b.id === zipID;
            }
          );
          //  Then apply it to your special mesh that's on top of everything else (added earlier in this file)
          momesh.datum(mo).attr("d", path);
          zipCode = zip.datum().properties.postalCode;
          factorChart.updateRadar(zipCode);

          tooltip.style("visibility", "visible");
          let bounds = path.bounds(zip.datum());

          let xPos = (bounds[0][0] + bounds[1][0]) / 2.0;
          let yPos = bounds[1][1];

          tooltip.attr("transform", `translate(${xPos},${yPos})`);
          txt.text(`Zip: ${zipCode}`);
        }

        function mouseLeavesZip() {
          tooltip.style("visibility", "hidden");
          let zip = d3.select(this);

          momesh.attr("d", "");
          factorChart.updateRadar();
        }
      };

      requestChoropleth();
    </script>
  </body>
</html>
